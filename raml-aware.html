<!--
@license
Copyright 2018 The Advanced REST client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer-element.html">
<script>
(function() {
  'use strict';
  const RAMLAware = {
    defaultScope: 'default',
    ramlAwares: new Map(),
    /**
     * Store for RAML definitions.
     * @type {Object<String, Object>} The key is a scope (`default` by default)
     * and the value is the RAML definition for this scope.
     */
    raml: {},
    /**
     * Attaches new RAML aware to the system. Added aware element will get
     * updates about new content.
     *
     * @param {RamlAware} aware The aware instance.
     */
    attachRamlAware: function(aware) {
      if (!this.ramlAwares.has(aware)) {
        const scope = aware.scope || this.defaultScope;
        this.ramlAwares.set(aware, scope);
        if (this.raml[scope] === undefined && aware.raml) {
          this.raml[scope] = aware.raml;
        }
        aware._initializeValues(scope, this.raml[scope]);
      }
    },
    /**
     * Removes avare from the map.
     * @param {RamlAware} aware Instance of the aware
     */
    detachRamlAware: function(aware) {
      if (!this.ramlAwares.has(aware)) {
        console.warn('The aware wasn\'t attached!');
        return;
      }
      this.ramlAwares.delete(aware);
      const scope = aware.scope;
      this.cleanUpData(scope);
    },
    /**
     * [setRaml description]
     * @param {HTMLElement} srcAware The aware that notified about the change
     */
    setRaml: function(srcAware) {
      const scope = srcAware.scope || this.defaultScope;
      const raml = srcAware.raml || undefined;
      this.raml[scope] = raml;
      for (let [aware, itemScope] of this.ramlAwares) {
        if (aware === srcAware) {
          continue;
        }
        const localScope = itemScope || this.defaultScope;
        if (localScope !== scope) {
          continue;
        }
        aware.raml = raml;
      }
    },

    scopeChanged: function(aware) {
      const scope = aware.scope || this.defaultScope;
      aware.raml = this.raml[scope];
      this.ramlAwares.set(aware, scope);
    },
    /**
     * Checks if
     * @param {[type]} scope [description]
     * @return {[type]} [description]
     */
    cleanUpData: function(scope) {
      for (let [, itemScope] of this.ramlAwares) {
        if (itemScope === scope) {
          return;
        }
      }
      this.raml[scope] = undefined;
    }
  };
  /**
   *
   * Element that is aware of the AMF (RAML, OAS) content.
   *
   * The element contains the same RAML data as other elements whenever their
   * location in the document. The RAML data are encapsulated in `scope` attribute.
   * By default the `scope` is `default`. If you create two `<raml-aware>`s with
   * different scopes then changing one raml will not affect the other.
   *
   * Setting a RAML data on a `<raml-aware>` will notify other awares with the same
   * scopes about the change and update their RAML data so it can be transfered
   * between different parts of application on even different web components.
   *
   * ### Example
   *
   * ```html
   * <raml-aware raml="{{raml}}" scope="request"></raml-aware>
   * <raml-aware raml="{{importRaml}}" scope="import"></raml-aware>
   * ```
   *
   * ```javascript
   * const r1 = document.querySelector('raml-aware[scope="request"]');
   * const r2 = document.querySelector('raml-aware[scope="import"]');
   * r1.raml = {};
   * r2.raml = null;
   * assert(r1.raml !== r2.raml);
   * ```
   *
   * ## Limitations
   *
   * `RamlAware` has to be attached to DOM for it to work. This element uses
   * web components callback methods to initialize value. If the component is
   * never attached it will never initialize it's values.
   *
   * @customElement
   * @polymer
   * @memberof ApiElements
   * @demo demo/index.html
   */
  class RamlAware extends Polymer.Element {
    static get is() { return 'raml-aware'; }
    static get properties() {
      return {
        /**
         * Scope for the RAML file.
         * Different awares may have different scope and keep different RAML objects.
         * It can be useful when one aware supports request panel and another
         * RAML import for example. In this case first one may have scope not set
         * (`default` scope) and second one `import` scope. Then both RAMLs are
         * encapsulated to the scope.
         */
        scope: {
          type: String,
          observer: '_scopeChanged'
        },
        // The RAML definition.
        raml: {
          type: Object,
          notify: true
        }
      };
    }
    static get observers() {
      return [
        '_ramlChanged(raml.*)'
      ];
    }

    connectedCallback() {
      super.connectedCallback();
      RAMLAware.attachRamlAware(this);
      this.__connected = true;
    }

    disconnectedCallback() {
      this.__connected = false;
      super.disconnectedCallback();
      RAMLAware.detachRamlAware(this);
    }

    _initializeValues(scope, raml) {
      if (!this.scope) {
        this.scope = scope;
      }
      if (!this.raml) {
        this.raml = raml;
      }
    }
    /**
     * Update RAML data for selected scope.
     */
    _scopeChanged() {
      if (!this.__connected) {
        return;
      }
      RAMLAware.scopeChanged(this);
    }
    /**
     * Notifies other awares about RAML change.
     */
    _ramlChanged() {
      if (!this.__connected) {
        return;
      }
      RAMLAware.setRaml(this);
    }
  }
  window.customElements.define(RamlAware.is, RamlAware);
})();
</script>
